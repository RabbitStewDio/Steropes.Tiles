using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Drawing;
using System.Linq;
using Steropes.Tiles.Matcher.Registry;
using Steropes.Tiles.Matcher.Sprites;
using Steropes.Tiles.Matcher.TileTags;
using Steropes.Tiles.Navigation;
using Steropes.Tiles.TemplateGenerator.Model;

namespace Steropes.Tiles.TemplateGenerator.Layout
{
  public class GridGenerator
  {
    public void Regenerate(TextureCollection c)
    {
      foreach (var grid in c.Grids)
      {
        if (grid.MatcherType == MatcherType.Basic)
        {
          continue;
        }

        var autoGens = grid.Tiles.Where(t => t.AutoGenerated).ToList();
        foreach (var tile in autoGens)
        {
          grid.Tiles.Remove(tile);
        }
      }

      Generate(c);
    }

    void Generate(TextureCollection c)
    {
      foreach (var grid in c.Grids)
      {
        if (grid.MatcherType == MatcherType.Basic)
        {
          continue;
        }

        if (grid.Tiles.Count > 0)
        {
          continue;
        }

        switch (grid.MatcherType)
        {
          case MatcherType.Basic:
            break;
          case MatcherType.CardinalFlags:
            GenerateCardinalFlags(grid);
            break;
          case MatcherType.CardinalIndex:
            GenerateCardinalIndex(grid);
            break;
          case MatcherType.CellMap:
            GenerateCellMap(grid);
            break;
          case MatcherType.Corner:
            GenerateCorner(grid);
            break;
          case MatcherType.Diagonal:
            GenerateDiagonal(grid);
            break;
          case MatcherType.NeighbourIndex:
            GenerateNeighbourIndex(grid);
            break;
          default:
            throw new ArgumentOutOfRangeException();
        }
      }
    }

    void GenerateNeighbourIndex(TextureGrid grid)
    {
      var ni = new Dictionary<NeighbourMatchPosition, Point>
      {
        {NeighbourMatchPosition.NorthWest, new Point(0, 0)},
        {NeighbourMatchPosition.North, new Point(1, 0)},
        {NeighbourMatchPosition.NorthEast, new Point(2, 0)},
        {NeighbourMatchPosition.West, new Point(0, 1)},
        {NeighbourMatchPosition.Isolated, new Point(1, 1)},
        {NeighbourMatchPosition.East, new Point(2, 1)},
        {NeighbourMatchPosition.SouthWest, new Point(0, 2)},
        {NeighbourMatchPosition.South, new Point(1, 2)},
        {NeighbourMatchPosition.SouthEast, new Point(2, 2)}
      };

      var reg = new NeighbourIndexTileRegistry<string>(new ReflectorRegistry(), NeighbourIndexTileRegistry<string>.LongSelector(), grid.Pattern);
      foreach (var name in ni)
      {
        var tileName = reg.Find(grid.Name, name.Key);
        var tile = new TextureTile(true, name.Value.X, name.Value.Y, tileName)
        {
          SelectorHint = name.Key.ToString()
        };
        grid.Tiles.Add(tile);
      }
    }

    void GenerateDiagonal(TextureGrid grid)
    {
      var keys = DiagonalTileSelectionKey.Values;
      var reg = new DiagonalTileRegistry<string>(new ReflectorRegistry(), null, grid.Pattern);
      for (var index = 0; index < keys.Length; index++)
      {
        var key = keys[index];
        var tileName = reg.Find(grid.Name, key);
        var x = index % 4;
        var y = index / 4;
        grid.Tiles.Add(new TextureTile(true, x, y, tileName)
        {
          SelectorHint = key.ToString()
        });
      }
    }

    void GenerateCorner(TextureGrid grid)
    {
      //
      // Arrange the tile for each bit combination in a 2x2 square 
      // and place each tile in a clock wise fashion based on the
      // direction (U, L, D, R) 
      void Add(Dictionary<CornerTileSelectionKey, Point> k, int idx)
      {
        var bv = new BitVector32(idx);
        var baseX = idx % 4 * 2;
        var baseY = idx / 4 * 2;

        k.Add(CornerTileSelectionKey.ValueOf(Direction.Up, bv[0], bv[1], bv[2]), new Point(baseX, baseY));
        k.Add(CornerTileSelectionKey.ValueOf(Direction.Right, bv[0], bv[1], bv[2]), new Point(baseX + 1, baseY));
        k.Add(CornerTileSelectionKey.ValueOf(Direction.Down, bv[0], bv[1], bv[2]), new Point(baseX + 1, baseY + 1));
        k.Add(CornerTileSelectionKey.ValueOf(Direction.Left, bv[0], bv[1], bv[2]), new Point(baseX, baseY + 1));
      }

      var keys = new Dictionary<CornerTileSelectionKey, Point>();
      for (var i = 0; i < 8; i += 1)
      {
        Add(keys, i);
      }

      var reg = new CornerTileRegistry<string>(new ReflectorRegistry(), null, null, grid.Pattern);
      foreach (var cornerKey in keys)
      {
        var tileName = reg.Find(grid.Name, cornerKey.Key);
        grid.Tiles.Add(new TextureTile(true, cornerKey.Value.X, cornerKey.Value.Y, tileName)
        {
          SelectorHint = cornerKey.Key.ToString()
        });
      }
    }

    void GenerateCellMap(TextureGrid grid)
    {
      var cellMapEntries = grid.EffectiveCellMapElements;
      if (cellMapEntries.Count <= 1)
      {
        cellMapEntries = new List<string>
        {
          "0",
          "1"
        };
      }

      var selectionFactory = TileTagEntrySelectionFactory.FromTags(cellMapEntries.ToArray());
      var selections = selectionFactory.ToSelectionArray();
      var tileCount = Math.Pow(selections.Length, 4);
      var width = (int) Math.Ceiling(Math.Sqrt(tileCount));
      foreach (var m4 in selections)
      {
        foreach (var m3 in selections)
        {
          foreach (var m2 in selections)
          {
            foreach (var m1 in selections)
            {
              var key = new CellMapTileSelectorKey(m1, m2, m3, m4);
              var tileName = key.Format(grid.Name, grid.Pattern);
              var x = key.LinearIndex % width;
              var y = key.LinearIndex / width;
              grid.Tiles.Add(new TextureTile(true, x, y, tileName)
              {
                SelectorHint = FormatCellMapSelectorKey(key)
              });
            }
          }
        }
      }
    }

    string FormatCellMapSelectorKey(CellMapTileSelectorKey k)
    {
      return $"{k.MatchA.Index},{k.MatchB.Index},{k.MatchC.Index},{k.MatchD.Index}";
    }

    void GenerateCardinalIndex(TextureGrid grid)
    {
      var ni = new Dictionary<CardinalIndex, Point>
      {
        {CardinalIndex.North, new Point(0, 0)},
        {CardinalIndex.East, new Point(1, 0)},
        {CardinalIndex.South, new Point(0, 1)},
        {CardinalIndex.West, new Point(1, 1)}
      };

      var reg = new CardinalIndexTileRegistry<string>(new ReflectorRegistry(), null, grid.Pattern);
      foreach (var name in ni)
      {
        var tileName = reg.Find(grid.Name, name.Key);
        grid.Tiles.Add(new TextureTile(true, name.Value.X, name.Value.Y, tileName)
        {
          SelectorHint = name.Key.ToString()
        });
      }
    }

    void GenerateCardinalFlags(TextureGrid grid)
    {
      var keys = CardinalTileSelectorKey.Values;
      var reg = new CardinalTileRegistry<string>(new ReflectorRegistry(), null, grid.Pattern);
      for (var index = 0; index < keys.Length; index++)
      {
        var key = keys[index];
        var tileName = reg.Find(grid.Name, key);
        var x = index % 4;
        var y = index / 4;
        grid.Tiles.Add(new TextureTile(true, x, y, tileName)
        {
          SelectorHint = key.ToString()
        });
      }
    }

    class ReflectorRegistry : ITileRegistry<string>
    {
      public string Find(string tag)
      {
        return tag;
      }

      public bool TryFind(string tag, out string tile)
      {
        tile = tag;
        return true;
      }
    }
  }
}